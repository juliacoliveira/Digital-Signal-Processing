# -*- coding: utf-8 -*-
"""ProjetoPDS-OFICIAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mZ8HJlxfk2AuV_LOh5lbVpMS-M2EgZwu
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq, ifft, rfft, irfft,rfftfreq
from scipy.signal import fftconvolve
from scipy import signal
from scipy.io import wavfile
from scipy.io.wavfile import write
from scipy.signal import welch, decimate
import scipy.io

#Carrega o arquivo
freqs, data = wavfile.read('349466__vr__high-alien.wav')
print(f"frequencia de amostragem = {freqs}")

audio = data[:,1]
n_amostras=audio.size
tamanho = n_amostras / freqs
print(f"duracao = {tamanho}s")
print(f"número de amostras = {n_amostras}")

#Plota as figuras ao longo do tempo
#Interpola para determinar eixo do tempo
time = np.linspace(0., tamanho, audio.size)
print(f"Time: {len(time)}")

plt.figure()
plt.plot(time, audio)
plt.title("Sinal de entrada")
plt.xlabel("Tempo [s]")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

N = audio.size #Número de amostras do canal direito

T = 1.0/freqs #período
y = audio[:N]
yf = fft(y)
xf = fftfreq(N,T)

#Plotando a FFT
plt.figure(1)
plt.plot(xf[0:N//2],2.0/N*abs(yf[0:N//2]))
plt.title("Sinal transformado")
plt.xlabel("Frequência")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

def convSobrepoeSoma(filtro, sinal):
    M = filtro.shape[0] #comprimento do filtro
    N = 2<<(M-1).bit_length()  #comprimento do bloco com os zeros
    L = N - M + 1 # comprimento do sinal a ser filtrado sem os zeros N=L+M-1 -> L=N-M+1
    L_sig = sinal.shape[0] # comprimento do sinal de entrada 
    blocos = range(0, L_sig, L)
    y = np.zeros(L_sig+N)

    FDir = rfft(filtro, n=N)

    # overlap and add
    for n in blocos:
        y[n:n+N] += irfft(rfft(sinal[n:n+L], n=N)*FDir)

    return y[:L_sig]

fir = np.genfromtxt("coef_fir2.csv",delimiter=",")

# convolução em bloco - metodo da sobreposição e soma
convolucao = convSobrepoeSoma(fir,y)

#Plot no tempo do sinal filtrado 
plt.plot(time[0:N],convolucao[0:N])
plt.title("Sinal filtrado")
plt.xlabel("Tempo [s]")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

fyt = fft(convolucao)

#Plot na frequência do sinal filtrado
plt.plot(xf[0:N//2],2.0/N*abs(fyt[0:N//2]))
plt.title("Sinal filtrado e transformado")
plt.xlabel("Frequência")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

#gera o audio a partir da convolução
data = np.random.uniform(-1,1,44100) # 44100 random samples between -1 and 1
scaled = np.int16(convolucao/np.max(np.abs(convolucao)) * 32767)
write('test.wav', 44100, scaled)

def dizimacao1(M):
    cont = 0
    y=[0]*(convolucao.size//M)
    aux = 0
    if convolucao.size%2==0:
      aux = 0
    else:
      aux = 1
    for i in range(0,convolucao.size-aux,M):
        y[cont] = convolucao[i]
        cont = cont + 1

    return y

#Dizimação
dizimacao = dizimacao1(2)

#Gera o gráfico no tempo do sinal dizimado e filtrado
length = audio.size // (22050)
time = np.linspace(0., length,len(convolucao))

plt.plot(time[:N//2],dizimacao[:N//2])
plt.title("Sinal filtrado e dizimado")
plt.xlabel("Tempo [s]")
plt.ylabel("Amplitude")
plt.grid()
plt.plot()
plt.show()

fd = fft(dizimacao,n=N)

#Gera o gráfico na frequência do sinal dizimado e filtrado
plt.plot(xf[0:N//2],2.0/N*abs(fd[0:N//2]))
plt.title("Sinal final na frequência")
plt.xlabel("Frequência")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

scaled = np.int16(dizimacao/np.max(np.abs(dizimacao)) * 32610)
write('testdezimacao.wav', 22050, scaled)